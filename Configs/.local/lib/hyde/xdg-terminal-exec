#!/bin/sh
set -euf
OIFS="$IFS"
N='
'
SELF_NAME=${0##*/}
RSEP=$(printf '%b' '\036')
USEP=$(printf '%b' '\037')
error() {
    printf '%s\n' "$@" >&2
}
check_bool() {
    case "$1" in
        true | True | TRUE | yes | Yes | YES | 1) return 0 ;;
        false | False | FALSE | no | No | NO | 0) return 1 ;;
        *)
            error "Assuming '$1' means no"
            return 1
            ;;
    esac
}
if check_bool "${DEBUG-0}"; then
    debug() {
        while IFS='' read -r debug_line; do
            printf 'D: %s\n' "$debug_line"
        done <<- EOF >&2
			$(printf '%s\n' "$@")
		EOF
    }
else
    debug() {
        :
    }
fi
shcat() {
    while IFS='' read -r line; do
        printf '%s\n' "$line"
    done
}
usage() {
    shcat <<- EOF
		Usage:
		  $SELF_NAME [options] [--] [command [arguments ...]]
	EOF
}
help() {
    shcat <<- EOF
		$SELF_NAME - Shell-based default terminal launcher.

		Implementation of the proposed Default Terminal Specification.

		$(usage)

		Launches given command in default terminal, or launches default terminal.

		Options for modifying terminal behavior (if supported by terminals's
		entry):

		  --app-id=app-id set app-id (Wayland) or window class (X11)
		  --title=title    set tile of terminal.
		  --dir=workdir    set workdir of terminal.
		  --hold           instruct terminal to hold after command ends.

		Options for printing data instead of executing terminal:

		  --print-id
		   print selected Desktop Entry ID. Action is appended delimited
		   by ":".

		  --print-path
		   print path to selected Desktop Entry. Action is appended
		   delimited by ":".

		  --print-content
		   print content of selected Desktop Entry. Conflicts with --print-cmd.

		  --print-cmd[=printf_sequence]
		   print resulting command line, delimited by given printf sequence,
		   "\\n" by default. If sequence is "\\n", output is also terminated with
		   a newline.

		  --print-delimiter=printf_sequence
		   printf sequence to be used as the delimiter between multiple requested
		   print statements, "\\n" by default. If sequence is "\\n", output is
		   also terminated with a newline.

		Configuration:

		Preferred terminals are configured by listing their Desktop Entry IDs
		in config files named "[\${desktop}-]xdg-terminals.list" placed in XDG Config
		hierarchy. Where "\${desktop}" is a lowercased string that is matched
		(case-insensitively) against items of "\${XDG_CURRENT_DESKTOP}".

		See "man $SELF_NAME" for more details.
	EOF
}
make_paths() {
    IFS=':'
    for dir in ${XDG_CONFIG_HOME:-"$HOME/.config"}$IFS${XDG_CONFIG_DIRS:-/etc/xdg}; do
        for desktop in $LOWERCASE_XDG_CURRENT_DESKTOP; do
            CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/$desktop-xdg-terminals.list
        done
        CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminals.list
    done
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share}; do
        for desktop in $LOWERCASE_XDG_CURRENT_DESKTOP; do
            CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminal-exec/$desktop-xdg-terminals.list
        done
        CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminal-exec/xdg-terminals.list
    done
    for dir in ${XDG_DATA_HOME:-$HOME/.local/share}$IFS${XDG_DATA_DIRS:-/usr/local/share:/usr/share}; do
        APPLICATIONS_DIRS=${dir%/}/applications/${APPLICATIONS_DIRS:+$IFS$APPLICATIONS_DIRS}
    done
    XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME/.cache"}
    CACHE_FILE="$XDG_CACHE_HOME/xdg-terminal-exec"
    debug "paths:" "  CONFIGS=$CONFIGS" "  APPLICATIONS_DIRS=$APPLICATIONS_DIRS"
}
alias make_paths='IFS= make_paths'
gen_hash() {
    read -r hash _drop <<- EOH
		$(
        hash_paths="$CONFIGS:$APPLICATIONS_DIRS"
        {
            echo 4
            echo "${XDG_CURRENT_DESKTOP-}"
            IFS=':'
            debug ">     hashing '${XDG_CURRENT_DESKTOP-}' and listing of:" $hash_paths "^     end of hash listing"
            LANG=C ls -LRl $hash_paths 2> /dev/null
        } | md5sum 2> /dev/null
    )
	EOH
    case "$hash" in
        [0-9a-f]??????????????????????????????[0-9a-f])
            debug "got fresh hash '$hash'"
            echo "$hash"
            return 0
            ;;
        *)
            debug "failed to get fresh hash, got '$hash'"
            return 1
            ;;
    esac
}
read_cache() {
    if [ -f "$CACHE_FILE" ]; then
        line_num=0
        line_limit=50
        cached_exec_usep=
        finished=0
        while IFS='' read -r line; do
            line_num=$((line_num + 1))
            case "$line_num" in
                1) cached_hash=$line ;;
                2) cached_cmd=$line ;;
                3) cached_entry_path=$line ;;
                4) cached_entry_id=$line ;;
                5) cached_entry_action=$line ;;
                6) cached_execarg=$line ;;
                7) cached_appidarg=$line ;;
                8) cached_titlearg=$line ;;
                9) cached_dirarg=$line ;;
                10) cached_holdarg=$line ;;
                "$line_limit")
                    debug "reached cache line limit ($line_limit)"
                    return 1
                    ;;
                *)
                    cached_exec_usep=$cached_exec_usep${cached_exec_usep:+$N}$line
                    case "$line" in
                        *"${RSEP}END_OF_EXEC_USEP")
                            cached_exec_usep=${cached_exec_usep%"${RSEP}END_OF_EXEC_USEP"}
                            finished=1
                            break
                            ;;
                    esac
                    ;;
            esac
        done < "$CACHE_FILE"
        if [ "$finished" = "1" ]; then
            debug "got cache:" \
                "hash=$cached_hash" \
                "cmd=$cached_cmd" \
                "entry_path=$cached_entry_path" \
                "entry_id=$cached_entry_id" \
                "entry_action=$cached_entry_action" \
                "execarg=$cached_execarg" \
                "appidarg=$cached_appidarg" \
                "titlearg=$cached_titlearg" \
                "dirarg=$cached_dirarg" \
                "holdarg=$cached_holdarg" \
                "exec_usep=$cached_exec_usep"
            HASH=$(gen_hash) || return 1
            if [ "$HASH" = "$cached_hash" ] && command -v "$cached_cmd" > /dev/null; then
                debug "cache is actual"
                EXEC_USEP=$cached_exec_usep
                ENTRY_PATH=$cached_entry_path
                ENTRY_ID=$cached_entry_id
                ENTRY_ACTION=$cached_entry_action
                EXECARG=$cached_execarg
                APPIDARG=$cached_appidarg
                TITLEARG=$cached_titlearg
                DIRARG=$cached_dirarg
                HOLDARG=$cached_holdarg
                return 0
            else
                debug "cache is out-of-date"
                return 1
            fi
        else
            debug "invalid cache data"
            return 1
        fi
    else
        debug "no cache data"
        return 1
    fi
}
save_cache() {
    if check_bool "$CACHE_ENABLED"; then
        [ ! -d "$XDG_CACHE_HOME" ] && mkdir -p "$XDG_CACHE_HOME"
        if [ -z "${HASH-}" ]; then
            HASH=$(gen_hash) || {
                error "could not hash listing of files, removing '$CACHE_FILE'"
                rm -f "$CACHE_FILE"
                return 0
            }
        fi
        case "$HASH$1$EXECARG$APPIDARG$TITLEARG$DIRARG$HOLDARG" in
            "$N")
                error "One or more of terminal's arguments contains a newline, removing '$CACHE_FILE'"
                rm -f "$CACHE_FILE"
                return 0
                ;;
        esac
        UM=$(umask)
        umask 0077
        printf '%s\n' \
            "$HASH" \
            "$1" \
            "$ENTRY_PATH" \
            "$ENTRY_ID" \
            "$ENTRY_ACTION" \
            "$EXECARG" \
            "$APPIDARG" \
            "$TITLEARG" \
            "$DIRARG" \
            "$HOLDARG" \
            "$EXEC_USEP${RSEP}END_OF_EXEC_USEP" > "$CACHE_FILE"
        umask "$UM"
        debug ">     saved cache:" "$HASH" "$EXEC_USEP" "$EXECARG" "$1" "^     end of saved cache"
    else
        debug "cache is disabled, removing '$CACHE_FILE'"
        rm -f "$CACHE_FILE"
        return 0
    fi
}
list_contains() {
    delimiter=${3:-$N}
    case "$delimiter$1$delimiter" in
        *"$delimiter$2$delimiter"*) return 0 ;;
        *) return 1 ;;
    esac
}
read_config_paths() {
    IFS=':'
    for config_path in $CONFIGS; do
        debug "reading config '$config_path'"
        [ -f "$config_path" ] || continue
        while IFS="$OIFS" read -r line; do
            case $line in
                /enable_cache)
                    debug "found '$line' directive${CACHE_CONFIGURED:+ (ignored)}"
                    [ -z "$CACHE_CONFIGURED" ] || continue
                    CACHE_ENABLED=true
                    CACHE_CONFIGURED=1
                    ;;
                /disable_cache)
                    debug "found '$line' directive${CACHE_CONFIGURED:+ (ignored)}"
                    [ -z "$CACHE_CONFIGURED" ] || continue
                    CACHE_ENABLED=false
                    CACHE_CONFIGURED=1
                    ;;
                /execarg_compat)
                    debug "found '$line' directive${EXECARG_COMPAT_CONFIGURED:+ (ignored)}"
                    [ -z "$EXECARG_COMPAT_CONFIGURED" ] || continue
                    EXECARG_COMPAT=true
                    EXECARG_COMPAT_CONFIGURED=1
                    ;;
                /execarg_strict)
                    debug "found '$line' directive${EXECARG_COMPAT_CONFIGURED:+ (ignored)}"
                    [ -z "$EXECARG_COMPAT_CONFIGURED" ] || continue
                    EXECARG_COMPAT=false
                    EXECARG_COMPAT_CONFIGURED=1
                    ;;
                /execarg_default:*:*)
                    if
                        ! check_bool "$EXECARG_COMPAT"
                    then
                        debug "ignored directive '$line' (strict mode)"
                        continue
                    fi
                    IFS=':' read -r _directive entry_id execarg_default <<- EOF
						$line
					EOF
                    if validate_entry_id "$entry_id"; then
                        debug "added TerminalArgExec default '$execarg_default' for '$entry_id'"
                        EXECARG_DEFAULTS=$EXECARG_DEFAULTS${EXECARG_DEFAULTS:+$N}$entry_id:$execarg_default
                    fi
                    ;;
                [a-zA-Z0-9_]* | [+-][a-zA-Z0-9_]*)
                    case "$line" in
                        [+-]*)
                            _line=${line#[+-]}
                            exclusion=${line%"$_line"}
                            line=$_line
                            ;;
                        *) exclusion='' ;;
                    esac
                    IFS=':' read -r entry_id action_id <<- EOL
						$line
					EOL
                    if validate_entry_id "$entry_id" && validate_action_id "$action_id"; then
                        case "$exclusion" in
                            '')
                                ENTRY_IDS=${ENTRY_IDS:+$ENTRY_IDS$N}$line
                                debug "added entry ID with action ID '$line'"
                                ;;
                            '+')
                                if
                                    list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"
                                then
                                    debug "entry '$entry_id' was already excluded from fallback"
                                elif list_contains "$INCLUDED_ENTRY_IDS" "$entry_id"; then
                                    debug "entry '$entry_id' fallback exclusion was already prevented"
                                else
                                    debug "preventing fallback exclusion for entry '$entry_id'"
                                    INCLUDED_ENTRY_IDS=${INCLUDED_ENTRY_IDS:+$INCLUDED_ENTRY_IDS$N}$entry_id
                                fi
                                ;;
                            '-') if
                                list_contains "$INCLUDED_ENTRY_IDS" "$entry_id"
                            then
                                debug "entry '$entry_id' fallback exclusion was already prevented"
                            elif list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"; then
                                debug "entry '$entry_id' was already excluded from fallback"
                            else
                                debug "excluding entry '$entry_id' from fallback"
                                EXCLUDED_ENTRY_IDS=${EXCLUDED_ENTRY_IDS:+$EXCLUDED_ENTRY_IDS$N}$entry_id
                            fi ;;
                        esac
                    else
                        error "Discarded possibly misspelled entry '$line'"
                    fi
                    ;;
            esac
        done < "$config_path"
    done
}
alias read_config_paths='IFS= read_config_paths'
replace() {
    r_remainder=$1
    REPLACED_STR=
    while [ -n "$r_remainder" ]; do
        r_left=${r_remainder%%"$2"*}
        REPLACED_STR=$REPLACED_STR$r_left
        if [ "$r_left" = "$r_remainder" ]; then
            break
        fi
        REPLACED_STR=$REPLACED_STR$3
        r_remainder=${r_remainder#*"$2"}
    done
}
de_expand_str() {
    debug "expander received: $1"
    EXPANDED_STR=
    exp_remainder=$1
    while [ -n "$exp_remainder" ]; do
        exp_left=${exp_remainder%%\\*}
        EXPANDED_STR=$EXPANDED_STR$exp_left
        debug "expander appended: $exp_left"
        if [ "$exp_left" = "$exp_remainder" ]; then
            debug "expander ended: $EXPANDED_STR"
            break
        fi
        exp_remainder=${exp_remainder#"$exp_left"\\}
        case "$exp_remainder" in
            s*)
                EXPANDED_STR=$EXPANDED_STR' '
                exp_remainder=${exp_remainder#?}
                debug "expander substituted space"
                ;;
            n*)
                EXPANDED_STR=$EXPANDED_STR$N
                exp_remainder=${exp_remainder#?}
                debug "expander substituted newline"
                ;;
            t*)
                EXPANDED_STR=$EXPANDED_STR'	'
                exp_remainder=${exp_remainder#?}
                debug "expander substituted tab"
                ;;
            r*)
                EXPANDED_STR=$EXPANDED_STR$(printf '%b' '\r')
                exp_remainder=${exp_remainder#?}
                debug "expander substituted caret return"
                ;;
            \\*)
                EXPANDED_STR=$EXPANDED_STR\\
                exp_remainder=${exp_remainder#?}
                debug "expander substituted backslash"
                ;;
        esac
    done
}
de_tokenize_exec() {
    debug "tokenizer received: $1"
    EXEC_USEP=
    tok_remainder=$1
    tok_quoted=0
    tok_in_space=0
    while [ -n "$tok_remainder" ]; do
        tok_left=${tok_remainder%%[[:space:]\"\`\$\\\'\>\<\~\|\&\;\*\?\#\(\)]*}
        EXEC_USEP=$EXEC_USEP$tok_left
        debug "tokenizer appended: >$tok_left<"
        case "$tok_remainder" in
            "$tok_left")
                debug "tokenizer is out of special chars"
                break
                ;;
        esac
        tok_remainder=${tok_remainder#"$tok_left"}
        cut=${tok_remainder#?}
        tok_char=${tok_remainder%"$cut"}
        unset cut
        tok_remainder=${tok_remainder#"$tok_char"}
        case "$tok_in_space$tok_left$tok_char" in
            1[[:space:]])
                debug "tokenizer still in space :) skipping space character"
                continue
                ;;
            1*)
                debug "tokenizer no longer in space :("
                tok_in_space=0
                ;;
        esac
        case "$tok_quoted$tok_char" in
            '1"')
                tok_quoted=0
                debug "tokenizer closed double quotes"
                continue
                ;;
            '0"')
                tok_quoted=1
                debug "tokenizer opened double quotes"
                continue
                ;;
            0[\`\$\\\'\>\<\~\|\&\;\*\?\#\(\)])
                debug "$entry_id: Encountered unquoted character: '$tok_char'"
                return 1
                ;;
            1[\`\$])
                debug "$entry_id: Encountered unescaped quoted character: '$tok_char'"
                return 1
                ;;
            1\\)
                case "$tok_remainder" in
                    '')
                        debug "$entry_id: Dangling backslash encountered!"
                        return 1
                        ;;
                    *)
                        cut=${tok_remainder#?}
                        tok_char=${tok_remainder%"$cut"}
                        tok_remainder=$cut
                        unset cut
                        EXEC_USEP=$EXEC_USEP$tok_char
                        debug "tokenizer appended escaped: >$tok_char<"
                        ;;
                esac
                ;;
            0[[:space:]])
                case "$tok_remainder" in
                    *[![:space:]]*)
                        EXEC_USEP=$EXEC_USEP$USEP
                        tok_in_space=1
                        debug "tokenizer entered spaaaaaace!!!! separator appended"
                        ;;
                    *)
                        debug "tokenizer entered outer spaaaaaace!!!! separator skipped, this is the end"
                        break
                        ;;
                esac
                ;;
            1[[:space:]\'\>\<\~\|\&\;\*\?\#\(\)])
                EXEC_USEP=$EXEC_USEP$tok_char
                debug "tokenizer appended quoted char: >$tok_char<"
                ;;
            *)
                debug "$entry_id: parsing error at char '$tok_char', (quoted: $tok_quoted)"
                return 1
                ;;
        esac
    done
    case "$tok_quoted" in
        1)
            debug "$entry_id: Double quote was not closed!"
            return 1
            ;;
    esac
    debug "tokenizer ended:" "$(
        IFS=$USEP
        printf '  >%s<\n' $EXEC_USEP
    )"
}
de_strip_fields() {
    exec_usep=''
    fu_found=false
    IFS=$USEP
    for arg in $EXEC_USEP; do
        case "$arg" in
            *[!%]'%'[dDnNvm]* | '%'[dDnNvm]*) debug "injector removed deprecated '$arg'" ;;
            *[!%]'%'[fFuU]* | '%'[fFuU]*)
                if
                    [ "$fu_found" = "true" ]
                then
                    debug "$entry_id: Encountered more than one %[fFuU] field!"
                    return 1
                fi
                fu_found=true
                debug "injector removed '$arg'"
                continue
                ;;
            *[!%]'%i'* | '%i'* | *[!%]'%c'* | '%c'*)
                debug "injector removed '$arg'"
                continue
                ;;
            *[!%]%%* | %%*)
                replace "$arg" "%%" "%"
                rarg=$REPLACED_STR
                debug "injector replacing '%%': '$arg' -> '$rarg'"
                exec_usep=$exec_usep${exec_usep:+$USEP}$rarg
                ;;
            *%?* | *[!%]%)
                debug "$entry_id: unknown % field in argument '$arg'"
                return 1
                ;;
            *)
                debug "injector keeped: '$arg'"
                exec_usep=$exec_usep${exec_usep:+$USEP}$arg
                ;;
        esac
    done
    EXEC_USEP=$exec_usep
    IFS=$OIFS
}
alias de_strip_fields='IFS= de_strip_fields'
reset_keys() {
    IS_TERMINAL=''
    EXEC_USEP=''
    EXECARG='-e'
    EXECARG_DEFINED=false
    APPIDARG=''
    TITLEARG=''
    DIRARG=''
    HOLDARG=''
}
find_entry_paths() {
    debug "registering entries"
    IFS=':'
    for directory in $APPLICATIONS_DIRS; do
        set -- "$@" "$directory".
    done
    set -- "$@" -type f
    or_arg=''
    for directory in $APPLICATIONS_DIRS; do
        set -- "$@" $or_arg '(' -path "$directory"'./[a-zA-Z0-9_]*.desktop' ! -path "$directory"'./*[^a-zA-Z0-9_./-]*' ')'
        or_arg='-o'
    done
    IFS=$N
    while read -r entry_path && read -r entry_id; do
        if list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"; then
            debug "entry '$entry_id' was excluded from fallback"
            continue
        fi
        alias "$entry_id"="entry_path='$entry_path'"
        debug "registered '$entry_path' as entry '$entry_id'"
        FALLBACK_ENTRY_IDS=$entry_id${FALLBACK_ENTRY_IDS:+$N$FALLBACK_ENTRY_IDS}
        debug "added fallback ID '$entry_id'"
    done <<- EOE
		$(find -L "$@" 2> /dev/null | awk '{ print; sub(".*/[.]/", ""); gsub("/", "-"); print }')
	EOE
}
alias find_entry_paths='IFS= find_entry_paths'
check_entry_key() {
    key="$1"
    value="$2"
    action="$3"
    read_exec="$4"
    de_checks="$5"
    case $key in
        'Categories'*=*)
            debug "checking for 'TerminalEmulator' in Categories '$value'"
            IFS=';'
            for category in $value; do
                [ "$category" = "TerminalEmulator" ] && {
                    IS_TERMINAL=true
                    return 0
                }
            done
            return 1
            ;;
        'Actions'*=*)
            [ -z "$action" ] && return 0
            debug "checking for '$action' in Actions '$value'"
            IFS=';'
            for check_action in $value; do
                if [ "$check_action" = "$action" ]; then
                    action_listed=true
                    return 0
                fi
            done
            return 1
            ;;
        'OnlyShowIn'*=*)
            case "$de_checks" in
                true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and OnlyShowIn '$value'" ;;
                false)
                    debug "skipping OnlyShowIn check"
                    return 0
                    ;;
            esac
            IFS=';'
            for target in $value; do
                IFS=':'
                for desktop in ${XDG_CURRENT_DESKTOP-}; do
                    [ "$desktop" = "$target" ] && return 0
                done
            done
            return 1
            ;;
        'NotShowIn'*=*)
            case "$de_checks" in
                true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and NotShowIn '$value'" ;;
                false)
                    debug "skipping NotShowIn check"
                    return 0
                    ;;
            esac
            IFS=';'
            for target in $value; do
                IFS=':'
                for desktop in ${XDG_CURRENT_DESKTOP-}; do
                    debug "checking NotShowIn match '$desktop'='$target'"
                    [ "$desktop" = "$target" ] && return 1
                done
            done
            return 0
            ;;
        'X-TerminalArgExec'*=* | 'TerminalArgExec'*=*)
            de_expand_str "$value"
            EXECARG=$EXPANDED_STR
            EXECARG_DEFINED=true
            debug "read TerminalArgExec '$EXECARG'"
            ;;
        'X-ExecArg'*=* | 'ExecArg'*=*)
            case "$EXECARG_COMPAT" in
                false) return 0 ;;
            esac
            de_expand_str "$value"
            EXECARG=$EXPANDED_STR
            EXECARG_DEFINED=true
            debug "read TerminalArgExec '$EXECARG'"
            ;;
        'X-TerminalArgAppId'*=* | 'TerminalArgAppId'*=*)
            de_expand_str "$value"
            APPIDARG=$EXPANDED_STR
            debug "read TerminalArgAppId '$APPIDARG'"
            ;;
        'X-TerminalArgTitle'*=* | 'TerminalArgTitle'*=*)
            de_expand_str "$value"
            TITLEARG=$EXPANDED_STR
            debug "read TerminalArgTitle '$TITLEARG'"
            ;;
        'X-TerminalArgDir'*=* | 'TerminalArgDir'*=*)
            de_expand_str "$value"
            DIRARG=$EXPANDED_STR
            debug "read TerminalArgDir '$DIRARG'"
            ;;
        'X-TerminalArgHold'*=* | 'TerminalArgHold'*=*)
            de_expand_str "$value"
            HOLDARG=$EXPANDED_STR
            debug "read TerminalArgHold '$HOLDARG'"
            ;;
        'TryExec'*=*)
            de_expand_str "$value"
            debug "checking TryExec executable '$EXPANDED_STR'"
            command -v "$(printf '%b' "$EXPANDED_STR")" > /dev/null || return 1
            ;;
        'Hidden'*=*)
            debug "checking boolean Hidden '$value'"
            case "$value" in
                true)
                    debug "ignored Hidden entry"
                    return 1
                    ;;
            esac
            ;;
        'Exec'*=*)
            case "$read_exec" in
                false)
                    debug "ignored Exec from wrong section"
                    return 0
                    ;;
            esac
            debug "read Exec '$value'"
            de_expand_str "$value"
            de_tokenize_exec "$EXPANDED_STR"
            de_strip_fields
            EXEC0=${EXEC_USEP%%"$USEP"*}
            debug "checking Exec[0] executable '$EXEC0'"
            command -v "$EXEC0" > /dev/null || return 1
            ;;
    esac
}
alias check_entry_key='IFS= check_entry_key'
read_entry_path() {
    entry_path="$1"
    entry_action="$2"
    de_checks="$3"
    read_exec=false
    action_listed=false
    debug "reading desktop entry '$entry_path'${entry_action:+ action '}$entry_action${entry_action:+'}"
    while IFS="$OIFS" read -r line; do
        case $line in
            '[Desktop Entry]'*) [ -z "$entry_action" ] && read_exec=true ;;
            [a-zA-Z0-9-]*)
                value=${line#*=}
                value=${value#"${value%%[! ]*}"}
                check_entry_key "$line" "$value" "$entry_action" "$read_exec" "$de_checks" && continue
                reset_keys
                debug "entry discarded"
                return 1
                ;;
            "[Desktop Action $entry_action]"*)
                if
                    [ "$action_listed" = "true" ]
                then
                    read_exec=true
                else
                    debug "action '$entry_action' was not listed in Actions"
                    return 1
                fi
                ;;
            '['*) [ "$read_exec" = "true" ] && break ;;
        esac
    done < "$entry_path"
}
validate_entry_id() {
    case "$1" in
        *[!a-zA-Z0-9_.-]* | *[!a-zA-Z0-9_.-] | [!a-zA-Z0-9_.-]* | [!a-zA-Z0-9_.-] | '' | .desktop)
            debug "string not valid as Entry ID: '$1'"
            return 1
            ;;
        *.desktop) return 0 ;;
        *)
            debug "string not valid as Entry ID '$1'"
            return 1
            ;;
    esac
}
validate_action_id() {
    case "$1" in
        '') return 0 ;;
        *[!a-zA-Z0-9-]* | *[!a-zA-Z0-9-] | [!a-zA-Z0-9-]* | [!a-zA-Z0-9-])
            debug "string not valid as Action ID: '$1'"
            return 1
            ;;
        *) return 0 ;;
    esac
}
find_entry() {
    de_checks=false
    IFS="$N"
    for entry_id in $ENTRY_IDS$N//fallback_start//$N$FALLBACK_ENTRY_IDS; do
        case "$entry_id" in
            *:*)
                entry_action=${entry_id#*:}
                entry_id=${entry_id%:*}
                ;;
            '') continue ;;
            '//fallback_start//')
                de_checks=true
                continue
                ;;
            *) entry_action='' ;;
        esac
        debug "matching path for entry ID '$entry_id'"
        alias "$entry_id" > /dev/null 2>&1 || continue
        eval "$entry_id"
        unalias "$entry_id"
        read_entry_path "$entry_path" "$entry_action" "$de_checks" || continue
        [ -z "$EXEC_USEP" ] && continue
        [ -z "$IS_TERMINAL" ] && continue
        if [ "$EXECARG_DEFINED" != "true" ]; then
            if check_bool "$EXECARG_COMPAT"; then
                EXECARG=$(get_default_execarg "$entry_id")
            else
                continue
            fi
        fi
        ENTRY_PATH=$entry_path
        ENTRY_ID=$entry_id
        ENTRY_ACTION=$entry_action
        return 0
    done
    IFS=':' error "No valid terminal entry was found in:" $APPLICATIONS_DIRS
    return 1
}
alias find_entry='IFS= find_entry'
get_default_execarg() {
    check_entry=$1
    while IFS=':' read -r entry_id execarg_default; do
        case "$entry_id" in
            "$check_entry")
                printf '%s' "$execarg_default"
                debug "custom default TerminalArgExec '$execarg_default' for '$check_entry'"
                return 0
                ;;
        esac
    done <<- EOF
		$EXECARG_DEFAULTS
	EOF
    printf '%s' '-e'
    debug "using default TerminalArgExec '-e' for '$check_entry'"
}
args=";;$(printf '%s;;' "$@")"
case "${args%%';;--;;'*};;" in
    *';;-h;;'* | *';;--help;;'*)
        help
        exit 0
        ;;
esac
LOWERCASE_XDG_CURRENT_DESKTOP=$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')
EXECARG_COMPAT=${XTE_EXECARG_COMPAT-true}
EXECARG_COMPAT_CONFIGURED=${XTE_EXECARG_COMPAT-}
EXEC_USEP=''
EXPANDED_STR=''
ENTRY_PATH=''
ENTRY_ID=''
ENTRY_ACTION=''
APPLICATIONS_DIRS=''
EXECARG_DEFAULTS=''
reset_keys
make_paths
CACHE_ENABLED=${XTE_CACHE_ENABLED-true}
CACHE_CONFIGURED=${XTE_CACHE_ENABLED-}
HASH=''
if check_bool "$CACHE_ENABLED" && read_cache; then
    CACHE_USED=true
else
    CACHE_USED=false
    ENTRY_IDS=''
    FALLBACK_ENTRY_IDS=''
    EXCLUDED_ENTRY_IDS=''
    INCLUDED_ENTRY_IDS=''
    read_config_paths
    find_entry_paths
    IFS="$N" debug ">     final entry ID list:" $ENTRY_IDS "^     end of final entry ID list"
    IFS="$N" debug ">     final fallback entry ID list:" $FALLBACK_ENTRY_IDS "^     end of final fallback entry ID list"
    find_entry || exit 1
fi
debug ">     original args:" "$@" "^     end of original args" "EXEC_USEP=$EXEC_USEP" "EXECARG=$EXECARG"
debug "option processing"
APPIDVAL=''
TITLEVAL=''
DIRVAL=''
HOLD=false
TEST_MODE=false
PRINT_DATA=
PRINT_DELIMITER='\n'
PRINT_CMD_DELIMITER='\n'
while [ "$#" -gt "0" ]; do
    case "$1" in
        --)
            debug "found explicit end of options $1"
            shift
            break
            ;;
        -e | "$EXECARG")
            debug "found exec arg $1"
            shift
            break
            ;;
        --app-id=*)
            debug "found option $1"
            IFS='=' read -r _opt APPIDVAL <<- EOF
				$1
			EOF
            debug "set app-id option to $APPIDVAL"
            shift
            ;;
        --title=*)
            debug "found option $1"
            IFS='=' read -r _opt TITLEVAL <<- EOF
				$1
			EOF
            debug "set title option to $TITLEVAL"
            shift
            ;;
        --dir=*)
            debug "found option $1"
            IFS='=' read -r _opt DIRVAL <<- EOF
				$1
			EOF
            debug "set dir option to $DIRVAL"
            shift
            ;;
        --hold)
            debug "found option $1"
            HOLD=true
            debug "set HOLD=true"
            shift
            ;;
        --test)
            debug "found option $1"
            TEST_MODE=true
            debug "set TEST_MODE=true"
            shift
            ;;
        --print-path)
            debug "found option $1"
            PRINT_DATA="$PRINT_DATA path"
            debug "set PRINT_DATA='$PRINT_DATA'"
            shift
            ;;
        --print-id)
            debug "found option $1"
            PRINT_DATA="$PRINT_DATA id"
            debug "set PRINT_DATA=$PRINT_DATA"
            shift
            ;;
        --print-content)
            debug "found option $1"
            PRINT_DATA="$PRINT_DATA content"
            debug "set PRINT_DATA=$PRINT_DATA"
            shift
            ;;
        --print-cmd)
            debug "found option $1"
            PRINT_DATA="$PRINT_DATA cmd"
            debug "set PRINT_DATA=$PRINT_DATA"
            shift
            ;;
        --print-cmd=*)
            debug "found option $1"
            PRINT_DATA="$PRINT_DATA cmd"
            IFS='=' read -r _arg PRINT_CMD_DELIMITER <<- EOF
				$1
			EOF
            debug "set PRINT_DATA=$PRINT_DATA" "set PRINT_CMD_DELIMITER=$PRINT_CMD_DELIMITER"
            shift
            ;;
        --print-delimiter=*)
            debug "found option $1"
            IFS='=' read -r _arg PRINT_DELIMITER <<- EOF
				$1
			EOF
            debug "set PRINT_DELIMITER=$PRINT_DELIMITER"
            shift
            ;;
        [!-]*)
            debug "found non-option $1"
            break
            ;;
        -*)
            debug "discarding unknown option $1"
            shift
            ;;
    esac
done
debug "end of option processing, prependig options"
PRINT_FIRST=true
case " $PRINT_DATA " in
    *' id '*)
        debug "acting on --print-id"
        printf '%s' "$ENTRY_ID${ENTRY_ACTION:+:}$ENTRY_ACTION"
        PRINT_FIRST=false
        ;;
esac
case " $PRINT_DATA " in
    *' path '*)
        debug "acting on --print-path"
        case "$ENTRY_PATH" in
            *'/./'*) ENTRY_PATH=${ENTRY_PATH%%/./*}/${ENTRY_PATH##*/./} ;;
        esac
        case "$PRINT_FIRST" in
            false) printf '%b' "$PRINT_DELIMITER" ;;
        esac
        printf '%s' "$ENTRY_PATH${ENTRY_ACTION:+:}$ENTRY_ACTION"
        PRINT_FIRST=false
        ;;
esac
case " $PRINT_DATA " in
    *' content '*)
        debug "acting on --print-content"
        case "$PRINT_FIRST" in
            false) printf '%b' "$PRINT_DELIMITER" ;;
        esac
        shcat < "$ENTRY_PATH"
        PRINT_FIRST=false
        ;;
esac
case " $PRINT_DATA " in
    '  ' | *' cmd '*)
        true
        ;;
    *' content '*)
        exit 0
        ;;
    *)
        case "$PRINT_DELIMITER" in
            '\n') printf '%b' '\n' ;;
        esac
        exit 0
        ;;
esac
if [ "$#" -gt 0 ] && [ -n "$EXECARG" ]; then
    set -- "$EXECARG" "$@"
    debug "prepended $1"
fi
if [ -n "$HOLDARG" ] && check_bool "$HOLD"; then
    set -- "$HOLDARG" "$@"
    debug "prepended $1"
elif [ -z "$HOLDARG" ] && check_bool "$HOLD"; then
    debug "terminal entry has no TerminalArgHold="
fi
if [ -n "$DIRARG" ] && [ -n "$DIRVAL" ]; then
    case "$DIRARG" in
        *=)
            set -- "$DIRARG$DIRVAL" "$@"
            debug "prepended $1"
            ;;
        *)
            set -- "$DIRARG" "$DIRVAL" "$@"
            debug "prepended $1 $2"
            ;;
    esac
elif [ -z "$DIRARG" ] && [ -n "$DIRVAL" ]; then
    debug "terminal entry has no TerminalArgDir="
fi
if [ -n "$TITLEARG" ] && [ -n "$TITLEVAL" ]; then
    case "$TITLEARG" in
        *=)
            set -- "$TITLEARG$TITLEVAL" "$@"
            debug "prepended $1"
            ;;
        *)
            set -- "$TITLEARG" "$TITLEVAL" "$@"
            debug "prepended $1 $2"
            ;;
    esac
elif [ -z "$TITLEARG" ] && [ -n "$TITLEVAL" ]; then
    debug "terminal entry has no TerminalArgTitle="
fi
if [ -n "$APPIDARG" ] && [ -n "$APPIDVAL" ]; then
    case "$APPIDARG" in
        *=)
            set -- "$APPIDARG$APPIDVAL" "$@"
            debug "prepended $1"
            ;;
        *)
            set -- "$APPIDARG" "$APPIDVAL" "$@"
            debug "prepended $1 $2"
            ;;
    esac
elif [ -z "$APPIDARG" ] && [ -n "$APPIDVAL" ]; then
    debug "terminal entry has no TerminalArgAppId="
fi
debug "end of option prepending"
IFS=$USEP
set -- $EXEC_USEP "$@"
IFS=$OIFS
debug ">     final args:" "$@" "^     end of final args"
if [ "$CACHE_USED" = "false" ]; then
    save_cache "$1" &
fi
case "$TEST_MODE" in
    true)
        printf '%s\n' 'Command and arguments:'
        printf '  >%s<\n' "$@"
        exit 0
        ;;
esac
case " $PRINT_DATA " in
    *' cmd '*)
        debug "acting on --print-cmd"
        case "$PRINT_FIRST" in
            false) printf '%b' "$PRINT_DELIMITER" ;;
        esac
        first=true
        for arg in "$@"; do
            case "$first" in
                true) first=false ;;
                false) printf '%b' "${PRINT_CMD_DELIMITER:-\n}" ;;
            esac
            printf '%s' "$arg"
        done
        if [ "$PRINT_CMD_DELIMITER" = '\n' ] || {
            [             "$PRINT_FIRST" = "false" ] && [ "$PRINT_DELIMITER" = '\n' ]
        }; then
            printf '%b' '\n'
        fi
        exit 0
        ;;
esac
if [ -z "$DIRARG" ] && [ -n "$DIRVAL" ]; then
    debug "no X-TerminalArgDir in entry, changing dir to '$DIRVAL'"
    cd "$DIRVAL"
fi
exec "$@"
